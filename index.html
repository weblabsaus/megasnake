<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Snake with Perfect Physics</title>
  <style>
    canvas {
      background: #000;
      display: block;
      margin: 20px auto;
      border: 2px solid #0F0;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // --- Constants ---
    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;
    const SEGMENT_LENGTH = 20;
    const NUM_SEGMENTS = 15;
    const RELAXATION_ITERATIONS = 8;
    const SPEED = 200; // pixels per second

    // --- Input Handling ---
    let keys = {};
    window.addEventListener('keydown', (e) => { keys[e.key] = true; });
    window.addEventListener('keyup', (e) => { keys[e.key] = false; });

    // --- Vector2 Class for basic vector operations ---
    class Vector2 {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      add(v) {
        return new Vector2(this.x + v.x, this.y + v.y);
      }
      subtract(v) {
        return new Vector2(this.x - v.x, this.y - v.y);
      }
      multiply(scalar) {
        return new Vector2(this.x * scalar, this.y * scalar);
      }
      length() {
        return Math.hypot(this.x, this.y);
      }
      normalize() {
        let len = this.length();
        return len === 0 ? new Vector2(0, 0) : new Vector2(this.x / len, this.y / len);
      }
    }

    // --- Snake Segment Class ---
    class Segment {
      constructor(x, y) {
        this.pos = new Vector2(x, y);
        this.prevPos = new Vector2(x, y);
      }
    }

    // --- Initialize Snake ---
    let snake = [];
    const startX = WIDTH / 2;
    const startY = HEIGHT / 2;
    for (let i = 0; i < NUM_SEGMENTS; i++) {
      // Place segments horizontally from the center
      snake.push(new Segment(startX - i * SEGMENT_LENGTH, startY));
    }

    // --- Main Simulation Update ---
    let lastTime = performance.now();
    function update(deltaTime) {
      // Update snake head using user input
      let head = snake[0];
      let inputDir = new Vector2(0, 0);

      if (keys["ArrowUp"]) inputDir.y -= 1;
      if (keys["ArrowDown"]) inputDir.y += 1;
      if (keys["ArrowLeft"]) inputDir.x -= 1;
      if (keys["ArrowRight"]) inputDir.x += 1;
      if (inputDir.x !== 0 || inputDir.y !== 0) {
        inputDir = inputDir.normalize();
      }

      // Verlet integration for head
      let tempPos = new Vector2(head.pos.x, head.pos.y);
      let velocity = head.pos.subtract(head.prevPos);
      // Apply acceleration: speed * deltaTimeÂ² ensures smooth motion over frames
      head.pos = head.pos.add(velocity).add(inputDir.multiply(SPEED * deltaTime * deltaTime));
      head.prevPos = tempPos;

      // Verlet integration for other segments (without additional acceleration)
      for (let i = 1; i < snake.length; i++) {
        let seg = snake[i];
        let temp = new Vector2(seg.pos.x, seg.pos.y);
        let vel = seg.pos.subtract(seg.prevPos);
        seg.pos = seg.pos.add(vel);
        seg.prevPos = temp;
      }

      // Constraint Relaxation: maintain constant distances between segments
      for (let iter = 0; iter < RELAXATION_ITERATIONS; iter++) {
        for (let i = 0; i < snake.length - 1; i++) {
          let segA = snake[i];
          let segB = snake[i + 1];
          let diff = segB.pos.subtract(segA.pos);
          let dist = diff.length();
          let error = dist - SEGMENT_LENGTH;
          if (dist !== 0) {
            // Divide the correction between both segments
            let correction = diff.normalize().multiply(error * 0.5);
            segA.pos = segA.pos.add(correction);
            segB.pos = segB.pos.subtract(correction);
          }
        }
      }
    }

    // --- Rendering Function ---
    function draw() {
      // Clear canvas
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // Draw snake body (line)
      ctx.strokeStyle = "#0F0";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(snake[0].pos.x, snake[0].pos.y);
      for (let i = 1; i < snake.length; i++) {
        ctx.lineTo(snake[i].pos.x, snake[i].pos.y);
      }
      ctx.stroke();

      // Draw each segment as a circle for clarity
      for (let segment of snake) {
        ctx.beginPath();
        ctx.arc(segment.pos.x, segment.pos.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = "#FFF";
        ctx.fill();
      }
    }

    // --- Game Loop ---
    function gameLoop(currentTime) {
      let deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      update(deltaTime);
      draw();
      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
